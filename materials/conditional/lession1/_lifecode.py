is_bool = False
is_second_bool = False


if is_bool:
    print('is_bool')
elif is_second_bool:
    print('is_second_bool')
else:
    print('oops')


"""
 Конструкция
 if
 elif
 else
 
 Может принимать в качестве аргументов любые переменные / объекты / литералы,
 но при этом они будут "интерпретироваться" как значения типа bool.
 Например:
    0 -> False
    1 -> True
    322 -> True
 
    "" -> False
    "text" -> True
 
    [] -> False
    [""] -> True
    ["qwerty"] -> True
 
    etc.
 
 Часто типы "контейнеры" при использовании в конструкции if elif else
 рассматриваются как bool объекты по их длине: 
    len(...) == 0 -> False
    len(...) > 0 -> True
"""

my_var = "1234"

if my_var:
    print(my_var)
elif my_var and True:
    1 / 0
else: # Так как язык python интерпретируемый, то мы можем выполнять код в котором заведомо есть ошибкио
    asasdf

my_second_var = True

if " ":
    # True or ... == True
    # False and ... == False
    print("my_second_var")
elif not my_second_var:
    print("not my_second_var")

"""
Конструкция match-case предназначена для операции сопоставления, но в отличие от других языков
программирования, данная конструкция имеет большую функциональность:

    1. Сопоставление с литеральными значениями строк / чисел
    2. Сопоставление списков
    3. Сопоставление по длине списка
    4. Сопоставление отдельных значений списков 
    etc.
"""

names = ["Max"]
names.append("Stepan")
names.append("Sasha")
names.append("Rostics")


match names:
    case [max, second_name, *_]:
        print(max, second_name)
    case "Stepan":
        print("Stepan")
    case "Sasha":
        print("Sasha")
    case _:
        print("Oops!")



# ['Max', 'Stepan', 'Sasha', 'Rostics']
"""
Распаковки 
Функционал распаковки доступен с помощью синтаксиса *. Распаковка позволяет получаться значения
из контейнерных и строк без обращения к значениям этих объектов по индексу.

Часто данный функционал используется для получения первого / последнего элемента[ов] объекта 
без обращения по индексам

Значения, которые не должны записаться в конкретную переменную будут записаны в переменную, которой
предшествует символ *

"""
n1, *other, n2= names
print(n1)
print(n2)
print(other)


"""

Тернарный оператор

Данный оператор позволяет проверять условие в сокращенной конструкции if else.
Тернарный оператор имеет следующий синтаксис 

    Действие1 if Условие1 else Действие2

При этом операндами, которые будут выполняться при выполнении условий могут быть 
как переменные / литералы / объекты, так и функции. 

Тернарный оператор часто используется при присваивании переменной одного из значений.

"""
print("Max") if "Max" in names else "Stepan"

value = None

"""
Логические операции с типами отличными от bool

Логические операции можно также применять с типами отличными от bool, как мы это делали в конструкции
if elif else и в тернарном операторе.

Результатом при использовании операторов or и and будет последний проверенный операнд.

При этом стоит заметить, что результатом выполнения в общем случае будет значение одного из операндов операторов,
а не значение типа bool (оператор not исключение).

"""

a = value or {"name": "not name"}
a = [] and 1 / 0 or 1
print(a)

"""
Конструкция try except позволяет обрабатывать исключения, возникаемые при 
выполнении программы и имеет полную форму:

try
    { Код, в котором может быть вызывано исключение. Пытается выполниться всегда }
except:
    { Код, который обрабатываем исключения из блока try. Выполняется в случае исключения в try }
else:
    { Код, который выполняется только, если в try не было вызвано исключение }
finally:
    { Код, который выполняется после выполнения всех предыдущих блоков. Выполняется всегда }
"""

try:
    1 / 0
except Exception as e:
    print("except")
else:
    print("else")
finally:
    print("finally")


"""
Побитовые операции

    & -> побитовое "и"
    | -> побитовое "или"
    ^ -> побитовое "xor"
    << -> побитовый сдвиг влево ( 1 << 10 == 1024 ~ 0b10000000000 )
    >> -> побитовый сдвиг вправо ( 1024 >> 5 == 16 ~ 0b10000 )
    
Операции производяться с целыми числами. Числа необходимо представлять в двоичном формате, то есть
операция 4 | 2 производится так, как будто бы вы попытались применить логическое сложение к 100 и 010,
результатом которого будет 110, и в результате операции вы получите число 6
"""

a = 1 << 2
# 0 -> 000
# 1 -> 001
# 2 -> 010
# 3 -> 011
# 4 -> 100
print(a)

print("\n.end")
